# import math
#print("hello")
import math
import cmath #complex math module
import numpy as np
import matplotlib
import matplotlib.pyplot as plt
#import sympy as sp # a possible way to use symbolic maths for analytical solutions

def model(a,b,c,x): # function that creates the model that is used

    y = a*math.pow(x,2) + b*x + c # Arbitary quadratic formula

    return y
def model_da(x):

    y = math.pow(x,2)

    return y

def model_db(x):

    y = x

    return y

def fps(a,b,c,x,h):
    # function that numerically determines turning point coordinate to model used. f'(a,b,c) = -f(a-2h,b-2h,c-2h)+.... see wiki for Five-point stencil
    p1 = model((a+(2*h)),(b+(2*h)),(c+(2*h)),x)
    p2 = model((a+h),(b+h),(c+h),x)
    p3 = model((a-h),(b-h),(c-h),x)
    p4 = model((a-(2*h)),(b-(2*h)),(c-(2*h)),x)
    y_prime = (-p1 + 8*p2 - 8*p3 + p4)/(12*h)

    return y_prime

def main():
    # User inputs all values needed for calculations.
    x_sep = 0.1#float(input("Input separation for each x value: ")) # Determines separation of x values
    x_lower_lim = -3#float(input("Input lower x limit: ")) # Lower x limit
    x_upper_lim = 3#float(input("Input Upper x limit: ")) # Upper x limit


    a = 1#float(input("Input a constant: ")) # Value for a
    b = 1#float(input("Input b constant: ")) # Value for b
    c = -1#float(input("Input c constant: ")) # Value for c
    h = 0.1#float(input("Input h value for derivative splice: ")) # Value for h

    x = np.arange(x_lower_lim,x_upper_lim,x_sep) # creates list from 1 to user input

    model_list = [] # Empty lists that will contain how the model changes with x for set parameters
    fps_list = []
    model_da_list = []
    model_db_list = []

    for i in x: #for loop that calculates all model values and appends them to list
        model_list.append(model(a,b,c,i))
        fps_list.append(fps(a,b,c,i,h))
        model_da_list.append(model_da(i))
        model_db_list.append(model_db(i))
        #print("For x co-ordinate: " + str(i))
        #print("The approximate value of the derivative is: " + str(y_diff))

    #for i in range(1,len(model_list)-1): # for/if loop that identifies turning point of model. Only suitable for 1 turning point in current state.
    #    if ((model_list[i-1] < model_list[i] and model_list[i+1] < model_list[i]) or (model_list[i-1] > model_list[i] and model_list[i+1] > model_list[i])):
    #        print("model turning point is approximately at coordinates: " + str(x[i]) + "," + str(model_list[i]))
    
    fig, ax = plt.subplots()
    ax.plot(x, model_list)
    ax.plot(x,fps_list)
    #ax.plot(x, model_da_list)
    #ax.plot(x, model_db_list)
    ax.legend(["Model","5PS model","Differentiated model wrt a", "Differentiated model wrt b"])
    ax.set_xlabel("x")
    ax.set_ylabel("Model")
    plt.show()

main()
