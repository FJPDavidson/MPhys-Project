import math
import numpy as np
import matplotlib
import matplotlib.pyplot as plt
from MPhys_param_class import create_parameter
from MPhys_functions import *

def main():

    print("Step 1: Reading file")
    # Reads in text file which lists all parameters being used in the simulation. it is in the form "name,value,h_step"
    filein = open("param_csv","r")
        
    parameter_name_list = []
    parameter_value_list = []
    parameter_hstep_list = []
    parameter_variation_list = []
    
    for line in filein.readlines():
        tokens = line.split(",")
        parameter_name_list.append(tokens[0])
        parameter_value_list.append(tokens[1])
        parameter_hstep_list.append(tokens[2])
        parameter_variation_list.append(tokens[3])

    filein.close()
    print("Done.")
    print("Step 2: Creating parameter objects.")
    model_parameters = []
    for item in range(0,len(parameter_name_list)):
        model_parameters.append(create_parameter(parameter_name_list[item],parameter_value_list[item],parameter_hstep_list[item],parameter_variation_list[item]))

    print("Done.")
    print("Step 3: Creating x range.")

    # User inputs all values needed for calculations.
    x_sep = 0.1###float(input("Input separation for each x value: ")) # Determines separation of x values
    x_lower_lim = 0.1###float(input("Input lower x limit: ")) # Lower x limit
    x_upper_lim = 3###float(input("Input Upper x limit: ")) # Upper x limit

    # Creates list of x values
    x = np.arange(x_lower_lim,x_upper_lim,x_sep) # creates list from 1 to user input
    print("Done.")
    print("Step 4: First Derivative")
    
    model_da_list = []
    fps1st_a = []
    fps1st_b = []
    fps1st_c = []
    fps1st_d = []
    fps1st_e = []

    value_list = parameter_value_list
    fps1st_list = []
    for p1 in range(0,len(parameter_name_list)):
        #print("Considering parameter, " + str(model_parameters[p1].name))

        double_pos_test_list = value_list[:]
        double_pos_test_list[p1] = float(model_parameters[p1].value) + 2*float(model_parameters[p1].h_step)
        single_pos_test_list = value_list[:]
        single_pos_test_list[p1] = float(model_parameters[p1].value) + float(model_parameters[p1].h_step)
        single_neg_test_list = value_list[:]
        single_neg_test_list[p1] = float(model_parameters[p1].value) - float(model_parameters[p1].h_step)
        double_neg_test_list = value_list[:]
        double_neg_test_list[p1] = float(model_parameters[p1].value) - 2*float(model_parameters[p1].h_step)

        for x_value in x:

            var = model_da(value_list[0],value_list[1],value_list[2],value_list[3],value_list[4],x_value)
            fps1st_a.append(var)

            part_1 = model_revised(double_pos_test_list,x_value)
            part_2 = model_revised(single_pos_test_list,x_value)
            part_3 = model_revised(single_neg_test_list,x_value)
            part_4 = model_revised(double_neg_test_list,x_value)

            fps1st = (-part_1 + 8*part_2 - 8*part_3 + part_4)/(12*float(model_parameters[p1].h_step))
            fps1st_list.append(fps1st)
    print("First derivative calculated.")

    print("Creating D")
    D_transpose = []
    for i in range(0,len(fps1st_list),len(x)):
        D_transpose.append(fps1st_list[i:i+len(x)])

    D = np.transpose(D_transpose)
    print("Done.")


    print("Step 5: Second derivative.")
    fps2nd_list = []
    for p1 in range(0,len(parameter_name_list)):
        for p2 in range(0,len(parameter_name_list)):
            if p1 != p2:
                
                #print("p1 = " + str(parameter_name_list[p1]) + ", p2 = " + str(parameter_name_list[p2])) 
                double_pos_test_list = value_list[:]
                double_pos_test_list[p1] = float(model_parameters[p1].value) + float(model_parameters[p1].h_step) 
                double_pos_test_list[p2] = float(model_parameters[p2].value) + float(model_parameters[p2].h_step)

                single_p1_pos_test_list = value_list[:]
                single_p2_pos_test_list = value_list[:]
                single_p1_pos_test_list[p1] = float(model_parameters[p1].value) + float(model_parameters[p1].h_step)
                single_p2_pos_test_list[p2] = float(model_parameters[p2].value) + float(model_parameters[p2].h_step)

                single_p1_neg_test_list = value_list[:]
                single_p2_neg_test_list = value_list[:]
                single_p1_neg_test_list[p1] = float(model_parameters[p1].value) - float(model_parameters[p1].h_step)
                single_p2_neg_test_list[p2] = float(model_parameters[p2].value) - float(model_parameters[p2].h_step)

                double_neg_test_list = value_list[:]
                double_neg_test_list[p1] = float(model_parameters[p1].value) - float(model_parameters[p1].h_step) 
                double_neg_test_list[p2] = float(model_parameters[p2].value) - float(model_parameters[p2].h_step)

                model_dadb_list = []
                for x_value in x:
                    var = model_dadb(value_list[0],value_list[1],value_list[2],value_list[3],value_list[4],x_value)
                    model_dadb_list.append(var)

                    part_1 = model_revised(double_pos_test_list,x_value) #f(x+h,y+k)
                    part_2 = model_revised(single_p1_pos_test_list,x_value) #f(x+h,y)
                    part_3 = model_revised(single_p2_pos_test_list,x_value) #f(x,y+k)
                    part_4 = model_revised(value_list,x_value) #f(x,y)
                    part_5 = model_revised(single_p1_neg_test_list,x_value) #f(x-h,y)
                    part_6 = model_revised(single_p2_neg_test_list,x_value) #f(x,y-k)
                    part_7 = model_revised(double_neg_test_list,x_value) #f(x-h,y-k)

                    fps2nd = (part_1 - part_2 - part_3 + 2*part_4 - part_5 - part_6 + part_7)/(2*float(model_parameters[p1].h_step)*float(model_parameters[p2].h_step))
                    fps2nd_list.append(fps2nd)

            if p1 == p2:
                #print("p1 = " + str(parameter_name_list[p1]) + ", p2 = " + str(parameter_name_list[p2]))
                single_pos_test_list = value_list[:]
                single_pos_test_list[p1] = float(model_parameters[p1].value) + float(model_parameters[p1].h_step)

                single_neg_test_list = value_list[:]
                single_neg_test_list[p1] = float(model_parameters[p1].value) - float(model_parameters[p1].h_step)
                
                model_dada_list = []
                for x_value in x:
                    var = model_dada(value_list[0],value_list[1],value_list[2],value_list[3],value_list[4],x_value)
                    model_dada_list.append(var)

                    part_1 = model_revised(single_pos_test_list,x_value)
                    part_2 = model_revised(value_list,x_value)
                    part_3 = model_revised(single_neg_test_list,x_value)

                    fps2nd = (part_1 - 2*part_2 + part_3)/math.pow(float(model_parameters[p1].h_step),2)
                    fps2nd_list.append(fps2nd)
    print("Second derivatives calculated.")
    print("Creating Z.")
    Z_transpose = []
    for i in range(0,len(fps2nd_list),len(x)):
        Z_transpose.append(fps2nd_list[i:i+len(x)])

    Z = np.transpose(Z_transpose)
    print("Done.")

    #print(D)
    #print(Z)
    DZ_stacked = np.concatenate((D,Z),axis=1)
    #print(np.shape(DZ_stacked))

    print("Step 6: Plotting...")
    fig, ax = plt.subplots() # Creates graph with x on x-axis and model values along y
    ax.plot(x, fps1st_a[:29],color='r')
    ax.plot(x, model_dada_list,color='b')
    ax.plot(x, D_transpose[0], '--',color='c')
    ax.plot(x, Z_transpose[0], '--',color='y')
    ax.legend(["Model_da","Model_dada","fps_a","fps_aa"])
    ax.set_xlabel("x")
    ax.set_ylabel("Model")
    plt.show()
    print("Done.")

main()
